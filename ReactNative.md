# React Native
[toc]

## Initial Setup
1. First, if we are planning to develop for Apple devices, we will need to intall X-code or, at the least, make sure it is up to date. Do thia through the app store.  Initially, at least, we will just be working in an OS X environment, developing for Apple; however, we can also develop for Android, and may come back and update these instruction if we do.

2. Next, if not already installed, install Node.js and NPM.

3. Next, install *watchman*, a utility that keeps an eye out for file changes. This can be installed using *homebrew*.

4.	Finally, install the React Native cli. This can be done with the command:
	```
	sudo npm install -g react-native-cli
    ```
5.	**Create An Initial App**: To start up an initial app, create the directory in which you want the app to reside, then enter at the command line:
	```
    react-native init [name of application]
    ```
    Now, to launch the project with React Native, we just go to the project directory and type the command:
    ```
    react-native run-ios
    ```
    This will launch the Apple simulator, so we can see the app in appearance. This takes a minute or two.
    
6.	At this point, we can open the directory in Atom and see that there is a tiny seed application, contained in *index.android.js* or *index.ios.js*

7.	**A Final Install**: It is good practice to use ES Lint for code validation. This can be set up in Atom, first by installing *linter* and then by installing *linter-eslint*.  After that is set up, install through npm an appropriate linting package (such as airbnb, etc.), and then create a *.eslintrc* file, which will look like:
	```javascript
    {
    	"extends": "[name of package]"
 	}
    
 ## Starting Up
 1.	Note that (until updated), these notes will reflect developing in iOS, and not Android.  So, in the seed app generated by the cli, we will create our entry into the app in the *index.ios.js* file.
 
 2.	Whenever we place content on the screen of a mobile device with ReactNative, we do so with a **component**. In this section, we will see how to create a single component to display on the screen.
 
 3.	To get started, we will need to import **both** React and React Native into the app. So, we start with:
 	```javascript
    //index.ios.js
    import React from 'react';
    import ReactNative from 'react-native';
    ```
    **React** has the task of creating and keeping track of our components.
    **React Native** is a separate library that that has the job of taking the output from components and rendering it to the mobile device. In addition, React Native provides a set of core components (text, image, view, etc.).
    
4.	To actually create the component, we write a javascript function that returns some code that describes that component.  To start off, we will create an "App" component, which will be the entire application for now.
	```javascript
    const App = () => {
      return (
        <Text>Test Text</Text>
      )
    }
    ```
    **Note**: If not already familiar with React and JSX, this will seem weird, having what looks like HTML inside the Javascript. JSX is a superset of Javascript written for React, so this is not actually HTML, but a flavor of Javascript that has syntax that looks like HTML.
    
5.	At this point, we have created a component and assigned it to the constant *App*; however, we have not done anything to actually place that component on the screen. For now, it merely exists in computer memory.

6.	In any React Native application, we must **register** at least one component to our application, which is done with the **registerComponent** method of the **AppRegistry** property of the ReactNative object. The registerComponent method takes two parameters, the first being the name of the app and the second being a function that returns the component.  So, we might see:
	```javascript
    ReactNative.AppRegistry.registerComponent('myApp', () => App);
    ```

7.	Finally, we need to modify our import statements.  First, for React Native, we need to specifically import the *Text* object so that we have access to it in our App component.  Also, we do not need to import the entire React Native module, but only the AppRegistry object.  Thus, a better import statement would be:
	```javascript
    import ReactNative, { Text } from 'react-native'; //one possibility
    
    import { AppRegistry, Text } from 'react-native';  //better
    ```
 
 8. **Our Big Result**: This is the complete code for what may be the world's ugliest app:
     ```javascript
    //Import libraries to create components
    import React from 'react';
    import { AppRegistry, Text } from 'react-native';

    //create a components
    const App = () => (
        <Text>Goodbye, Cruel World!t</Text>
    );

    //render the component to the device
    AppRegistry.registerComponent('albums', () => App);
    ```
 
 9. **Debugging**: To get some feedback when developing in iOS, click *Command + D* on the simuulator, then click on "Debug Remote JS*, which will open a browser window, allowing us to access developer tools. However, this will make the simulator run slower. Also, we can include in our code **"debugger"** statements to interrupt the flow of the program.
 
 ##	Working With Components
 
 ### Setting Up
 1.	In creating a more extensive app, we will be making numerous components, which allows for reusability. So, in our app directory structure, we will want to have an organized way of holding these components.  In addition, there should be **only one component definition in a file**. So, to start off, we will probably want to create the following directory:
 	```
    projectRoot/src/components
    ```

### Functional vs. Class Components
1. In React, there are two basic types of components. The majority of components will be **functional components**, meaning they are functions that return some jsx to be displayed on the device. However, they cannot handle tasks such as fetching data or dealing with dynamic sources of data.  For components that need these capabilities, we must use **class-based components**.

 2. *Functional Components* are used when we are only displaying data that we already have. Typically, most components in an app will be functional components, and their use is preferred when class based components are not necessary.  A basic example of a functional component might be:
     ```javascript
     const Header = () => (
         <Text>
             Hello
         </Text>
     )
     ```
 
 3. *Class-Based Components* are written in ES6 class syntax, as in the following example (of a header component that should be written as a functional components):
     ```javascript
     class Header extends Component {
         render() {
             return<Text>Hello</Text>
         }
     }
     ```
 4. In order to write the class-based component, we will first need to import the Component object from React, as follows:
     ```javascript
     import React, { Component } from 'react';
     ```
 5. A class-based component **must contain a render() method**, which returns some amount of jsx.
 
 6. One big advantage of class-based components is the ability to use **life-cycle methods**.
 
### Life-Cycle Methods
1. React has several methods built-in that address the different parts of the component life-cycle.  Actions specified in these methods will fire only one time, at the appropriate point in the life-cycle.  These points are stated in terms of **mounting** or **unmounting** of components.  A component is *mounted* when it is added to the DOM, and *unmounted* when it is removed from the DOM.  Stage methods include:

    a. **componentWillMount**: At this stage, the component is about to go into the DOM.  We do not have access to the DOM, but we do have access to *state* and *props*.

    b. **componentDidMount**: At this stage, the component has been placed into the DOM, and we have access to the component in the DOM. So, for example, the following would show the actual HTML node object in the DOM:
    ```javascript
    componentDidMount() {
        console.log(ReactDOM.findDOMNode(this));
    }
    ```
    
    c. **componentWillUnmount**: At this stage, the component is just about to be removed from the DOM.  This is where we can clean up any processes that were set up on the component. For example, if we *addChangeListener* in the earlier stages, then we should *removeChangeListener* at this stage.
    
    d. **componentWillUpdate()**: At this stage, the component is about to rerender because there has been a change in application state.
		
2. ReactDOM has a method *unmountComponentAtNode()*, which is the inverse of the ReactDOM.render() method.  It takes a single parameter, the node where the component is mounted.  For example:
    ```javascript
    unmount() {
        ReactDOM.unmountComponentAtNode(document.getElementById('app'))
    }

3. The following are a number of commonly used methods relating to the lifecycle of a component:

    a. **defaultProps** sets values that the props for the component will have on its initial rendering:
    ```javascript
    class App extends React.Component {
        . . .
    }
    App.defaultProps = {
        age: 20,
        name: 'Jordan'
    }
    ```
    b. **componentWillReceiveProps(nextProps)** takes the *nextProps* parameter, which are the props that will be when the component renders next. Examine the following:
    ```javascript
    componentWillReceiveProps(nextProps){
        this.setState({
        increasing: nextProps.val > this.props.val
        })
    }
    ```
	The above code tells React to wait until the component is about to receive new props, then compare the props.val that it will become (*i.e.*, nextProps.val) with what is there already (*i.e.*, this.props.val).
	
    c. **shouldComponentUpdate(nextProps, nextState)** allows us to examine the props and state that will be, and decide if the component should rerender, which it does if the method returns *truthy*.  For example, if we wanted to rerender a button after every fifth click, we could keep count and return true if prop % 5 === 0, for example.  **NOTE:** The state and props are still updating, they just aren't causing a rerendering.
	
    d. **componentDidUpdate(prevProps, prevState)** allows us to examine what the immediately prior state and props were and perform any actions.

## Component Level State
1. Example: In our *class-based component* we want, at the *componentWillMount* stage, to make an AJAX request to get some data, which we are then going to display in our component. **The Big Problem** is that the AJAX request is asynchronous and by the time the data gets back to us, the *render* method has run and put our page on the screen, without our data.  By this point, there is no way to make the screen re-render with the data once it arrives.

2. This is handled by the React construct of **state (or component-level state)**. Simply put, when a component interpolates data from the **state** object, it rerenders when the values in the state object are updated (assuming it is done correctly, using the **setState()** method.

3. To use component state to handle this situation, we will do the following:

    a. **Set the default, initial state for our component**: To set the default, initial state, simply add a class level property of **state**:
    ```javascript
    class AlbumList extends Component {
        state = { albums: [] };
    }
    ```
    The above will set up an initial state with an empty array for our list of albums. **This is required to prevent the app from breaking.**
    
    b. **After fetching the data, tell the component state to update**: When our data returns, we must run the Component method **setState**, which takes an object as a parameter, being the updated properties, as follows:
    ```javascript
    class AlbumList extends Component {
        componentWillMount() {
            fetch('https://rallycoding.herokuapp.com/api/music_albums')
                .then(res => res.json())
                .then(res => this.setState({
                    albums: res
                }));
            }
    ```
    In order to force a rendering, **this.setState** must be used. It will not work if state is updated by simple assignment.
    
    
    c. make sure the component makes use of the updated state.

4. **STATE vs PROPS**: We will use the **props** object to communicate from a parenty to a child component, by passing in the props on the child component tag. In constrast, we use **state** to keep track of a component's internal data.
    
### Creating A Nested Component
1.	Then, we will create a new component (a header).  To do this, create the file **Header.js** inside the components directory, and then create a basic component as before. The one difference is that instead of registering our component after it is made, we will **export** it so it is available to other parts of our app. So, we have:
	```javascript
    //src/component/Header.js
	import React from 'react';
	import { Text } from 'react-native';

	const Header = () => (
		<Text>Goodbye, Cruel World!</Text>
	);

	export default Header;
	```

2. Now that this component is available, we can go back to our *index.ios.js* file and import the component, then place, or **nest**, it into our App component, as follows:
    ```javascript
    import React from 'react';
    import { AppRegistry } from 'react-native';
    import Header from './src/components/Header';

    //create a components
    const App = () => (
        <Header />
    );

    //render the component to the device
    AppRegistry.registerComponent('albums', () => App);
    ```

## Building a List of Components

1. To create our list of components, we take the array of data returned and use the **map** array iterator method to make a component for each array entry. For example, suppose we have fetched JSON data for a list of record album objects. We would create our list of albums as follows:
    ```javascript
    createAlbumList() {
        return this.state.albums.map(album => <Text>{album.title}</Text);
    }
    ```
2. Next, we call the method to generate our list in the *render()* method:
    ```javascript
    render() {
        return (
            <View>
                {this.createrAlbumList()}
            </View>
        );
    }
    ```
    **NOTE**: In both the examples above, we inteerpolate data into JSX with **single brackets**.
    
    **NOTE**: To prevent a warning message, we need to add a unique **key value**  to each item. The key must be unique and we must be able to depend on it being the same on each render; using the index is not a good idea, because the data could come back next time in different order.  

### Styling
1.	React Native does not yet have any frameworks such as Bootstrap to handle styling of components.
  
2.	Styling of a component is performed via an object in the component file with the styling properties. **It is not using CSS**, but a lot of the properties will look familiar (usually using camel case instead of hyphens, for example).
  
3.	As an example, we will increase the font size of the text in the Header component.  To do so, we do the following:

	a)	create a *styles* object in our component file.
    
    b)	include as a property of that object an object containing styling (we can think of it as being sort of like a CSS tag),
    
    c)	pull that property into our component definition function,
    
    d)	pass the property into our component as a **prop** (more on this later).
    
 4. For example, our code might look like:
    ```javascript
    //src/components/Header.js
    import React from 'react';
    import { Text } from 'react-native';

    const Header = () => {
        const { myStyle } = styles;
        return (
            <Text style={myStyle}>Albums!</Text>
        );
    };

    const styles = {
        myStyle: {
            fontSize: 40,
            color: 'red'
         }
    };

    export default Header;
    ```
    
5.	**SIDE NOTE REGARDING TAGS**: Don't get too confused with the fact that the tags supplied by React Native look just like HTML tags.  We cannot use them interchangably, for example, we cannot have:
    ```html
    <div>
        <Text>Blah, Blah</Text>
        <Text>More Blah</Text>
    </div>
    ```
    The equivalent of a **\<div>** tag for React Native is the **\<View></View>** tag, which allows us positioning, and which can also wrap multiple \<Text></Text> or other tags within it.


## Passing Data from Parent to Child (Props)
1.	Currently, the Header component that we made has text hard-coded into it.  Obviously, if we want to use this Header in many situations, we will need a way to pass to it the text we wish to display.  

2.	To pass the text we want to display in the Header, we need to do the following:

	a.	determine what data we want to get from the parent component,
    
    b.	place a *props* objecty as an argument to the function creating our child component,
    
    c.	use **single braces** to interpolate the props object into the component, so our component might look like:
	```javascript
	const Header = (props) => {
	  const { textStyle, viewStyle } = styles;
	    return (
          <View style={viewStyle}>
            <Text style={textStyle}>{props.title}</Text>
	      </View>
	    );
	};
    ```
    d.	In the parent component, when the child component is placed, include the desired prop as an attribute of that component, for example:
    ```javascript
    const App = () => {
      <Header title="Howdy" />
    );
    ```
3. **props.children**: Any time that a component is passed into another component (by nesting), the nested component is included in the props object of the component as the **props.children** property.

## Creating a List of React Components
1. A very common task is obtaining a JSON object of information about a list of items, then rendering our list into the browser. Typically, what we will want to do is create a model component that will interpolate the JSON data, and then repeat that component, as demonstrated herein.

2. First, we will create a list component, which will be responsible for obtaining the data (such as from a third-party api), then creating the list.  Then, we will create a child component, that will be repeated in the list.

     a. To start, create the list component file in our components folder, with a simple starter content, as follows:
     ```javascript
    import React from 'react';
    import { View, Text } from 'react-native';

    const AlbumList = () => (
        <View>
            <Text>Album List??</Text>
        </View>
    );

    export default AlbumList;     
     ```
    b. Place the component in the *index.ios.js* page (assuming that is where it is supposed to go, remembering that a component can only return a single tag, as follows:
    ```javascript
    import React from 'react';
    import { AppRegistry, View } from 'react-native';
    import Header from './src/components/Header';
    import AlbumList from './src/components/AlbumList';

    const App = () => (
        <View>
            <Header title='Howdy!' />
            <AlbumList />
        </View>
    );

    //render the component to the device
    AppRegistry.registerComponent('albums', () => App);
    ```

## Creating a List, Part II
1. The method above works fine for creating a list; however, for a long list, especially in the mobile context, it can be resource wasteful. In this section, we explore an alternative method of rendering the list.

2. React Native includes a component called **ListView**. This works by figuring out the items that are actually visible on the screen, and then creates components **only** for those items. It also watches for scrolling events to keep track of what items it should show. As the item goes off the top of the screen, for example, the component is removed from the top and added to the bottom of the list, with the correct data.

3. To set up the ListView:

    a. In the component where we are making our list, import as follows:
    ```javascript
    import { ListView } from 'react-native'
    ```
    b. In the componentWillMount lifecycle hook, create our list. First, we include a bunch of what can be considered boilerplate, as follows:
    ```javascript
    class LibraryList extends Component {
        componentWillMount() {
            const ds = new ListView.DataSource({
                rowHasChanged: (r1, r2) => r1 !== r2
            });
            this.dataSource = ds.cloneWithRows(this.props.libraries);
        }

        renderRow() {

        }

        render() {
            return (
                <ListView
                    dataSource={this.dataSource}
                    renderRow={this.renderRow}
                />
            );
        }
    }
    ```
    Notice that in the above boilerplate we do have a reference to our data, *this.props.libraries*, as the parameter supplied to the *cloneWithRows* method.  We then use the **renderRow()** method to create our individual instance of an item.
    
    c. We can create a new component for our list item, then in our list component, we will need to import the list.  In our **renderRow()** method, we must include a parameter, which will represent a single object in our list.  We pass that as a prop to our list item:
    ```javascript
    renderRow(library) {
        return (
            <ListItem library={library} />
        );
    }
    ```


## Handling User Response

1. To allow interaction with the device, some components will be able to handle user input events. These events will be included as a prop, and will be assigned an event handler function. For example, the TextInput component can take the "onChangeText" event, and run the event handler whenever the text in the box is altered.  For example, an input component (which incorporates a react-native Text Input component, may appear as:
    ```jsx
    <Input
        secureTextEntry
        placeholder='password'
        label='Password'
        value={this.state.password}
        onChangeText={password => this.setState({ password })}
    />
    ```
 2. Available events include:
 
    a. **onChangeText**: TextInput
    
    b. **onPress**: TouchableOpacity

## Styling

We have gone into styling a little bit previously, however, the point at that time was simply to show how styling is inserted into our components through its props. In this section, we will cover the actual styling.

### Positioning With Flexbox

1.	**Flexbox**, in React Native, works for the most part in the same manner that it works in CSS. For some background in the use of flexbox, see the article at: https://css-tricks.com/snippets/css/a-guide-to-flexbox/.

2.	Flexbox is a means of positioning elements within a container. The container will normally be the <View> tag, and the elements might be <Text> tags.

3.	In regular CSS, *justify-content* is used to position elements horizontally, and *align-items* is used to position elements vertically. However, this is switched in React Native, so **justifyContent** will align itsms vertically, and **alignItems** will position elements horizontally. Each of them can take the properties:

    **flex-start**: Places the items at the top or left,
    
    **center**: places the items in the center,
    
    **flex-end**: places the items in the bottom or right

4.  Of course, to see verticle alignment, we will need to designate a height for our <View>, which can be done using the **height** property.

5. Note that the *justifyContent* and *alignItems* properties seem to be reversed from their use in normal css. There is a **flexDirection** property, which designates the main axis, and this defaults to "column" in React Native and "row" in desktop.

### Border
1. To view the styles supported in React Native, see the React Native documentation.  However, this is a very nice looking styling for a border:
    ```javascript
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2
    ```
    
### Images
1. In React Native, images will not show unless the image tag is given an exact size in styling. 

### Layout Animations
1. React Native provides a number of animations. One particular example is LayoutAnimation. To create a layout animation, first import "LayoutAnimation" from 'react-native'.  Then, in the **componentWillMount** cyle hook, include the following:
    ```
    componentWillUpdate() {
        LayoutAnimation.spring();
    }
    ```
2. Note, however, that layout animation is a somewhat blunt weapon. It animates *everything* that changes upon the rerendering of a view (which happens because of an update to application state).

## Sample: Auth App
1. This section will cover issues encountered in the "auth" app contained in this directory. It will do very little other than the login, (or register for a new user) by e-mail and password, and then allow the user to log out.  In addition, this app will introduce the use of Firebase in order to persist the registration data.

2. One note about this instructional app. It will have only one screen for login and for registration. If the user logs in and the e-mail address is not recognized, then the user is registered with that name and password.

3. **Setup Note**: Note that in the basic setup provided by the *init* command, we get an App component in both the *index.android.js* and the *index.ios.js* files. This allows separate configuration for the two platforms; however, we will often not need to have and separate configuration, and it is better to have the App component exist independently of these files, so that we don't have to update in two different places, for example.

4. **Exporting Components from a Directory**: In our *src/components/common* directory, we have a large number of components. Rather than having to import each one separately into another conponent, we can "bundle them up" by creating an **index.js** file in the directory and exporting from that file, which may look like:
    ```javascript
    export * from './Button';
    export * from './Card';
    export * from './CardSection';
    export * from './Header';
    ```
    Note, however, that this will require that, rather than using the *default* keyword in the export statement at the bottom of each component, we will need to specifically export an object, as follows:
    ```javascript
    export {
        Button
    }
    ```
### Firebase
1. **Firebase** is an online database, owned by Google that we can connect to directly from our app. It has a number of capabilities, including the ability to notify each user of changes to data by other users, to enable contemporaneous updating. In our case, we will use it for our authentication.

2. In the "Get Started" section, we will see choices to add Firebase to our iOS/Android/Web app. Choose the web app option.

3. The first step is to create our project.  Then, we need to go to the Authentication tab and choose our method of authentication. In choosing a type of authentication, we will use Email/Password, as React Native does not currently work well with OAuth providers.

4. Next, we install the Firebase library as an NPM module.

5. When we set up the Firebase project, it created a bucket of data to hold our data. We will need to hook into that bucket upon initiating the app. We will do that in the App component, using the *componentWillMount* hook. Do the following:

    a. import firebase into the App file,
    
    b. in the *componentWillMount()* hook, use the **initializeApp** method of Firebase. As a parameter, include the object that is assigned to **config** in the Web Setup modal on the Firebase website.
    
### Handling Text Input
 1. To get user input, we can use the TextInput component from the React Native library.
 
 2. The TextInput component do not render with a default height an width. These must be specified, or else the textInput component will be invisible. In addition, there is no other styling whatsoever. It will only show text to its width, although more text may be entered.
 
3. To have access to the text that the user inputs, we must use the **component state**. So, we will have to do the following:

    a. initialize our state in the LoginForm component, with a "text" value.
    
    b. give our TextInput component a prop of **onChangeText** which will be assigned an event handler that will use **setState()** to update the state.
    
    c. give our TextInput component a prop of **value**, which we assign the value of *this.state.text*.  So, we have:
    ```javascript
    <TextInput
        value={this.state.text}
        onChangeText={text => this.setState({ text })}
        style={{ height: 20, width: 100 }}
    />
    ```
    When we type into the text box, as soon as we press a key, the state is updated and the value prop is updated, and the TextBox is rerendered with the new text.

4. There are a number of propw provided for the TextInput component by React Native.  Take a look at the sample application to see many of them in use. One thing to keep in mind is that if a prop takes a boolean value, then we can simply pass the prop name into the parent tag, and if we don't, its value will be *undefined*, or *falsey*. For example, the **secureTextEntry** takes a boolean (either we want the text to appear as dots, or not).  So, in our tag, we have:
    ```javascript
    <Input secureTextEntry />
    ```
    and in our component, we have:
    ```javascript
    <TextInput
        secureTextEntry={secureTextEntry}
    />
    ```
### Signing In With Firebase
1. We are keeping track of our email and password in the component state. So, we want to be able to log in when we touch the "Log in" button. To do so, take the following steps:

    a. to our button, add as a prop the event handler **onPress**, and assign to it a method of onButtonPress, as follows:
    ```javascript
    <Button onPress={this.onButtonPress.bind(this)}>
        Log in
    </Button>
    ```
    Note that we need to bind our method to the current scope (this), since it may be called elsewhere.
    
    b. Next, we need to create a method in our class, onButtonPress, which will use a Firebase method to do the auth (don't forget to import firebase):
    ```javascript
    onButtonPress() {
        const { email, password } = this.state;
        Firebase.auth().signInWithEmailAndPassword(email, password);
    }
    ```
    
    c. The firebase method we use returns a promise. If the login is successful, we want to show the user a welcome screen; if the login is unsuccessful, we want to try registering the user. If we are unsuccessful registering, then we need to show an error message. Going down the error chain, we end up with:
    ```javascript
    onButtonPress() {
        const { email, password } = this.state;
        Firebase.auth().signInWithEmailAndPassword(email, password)
            .catch(() => {
                Firebase.auth().createUserWithEmailAndPassword(email, password)
                    .catch(() => {						
                    
                    });
            });
    }
    ```
    d. The firebase.auth() object also has an event listener method called **onAuthStateChanged()**, which takes an event handler which is fired whenever the authorization status changes. The event handler takes one parameter, representing the user.   


## Redux
1. As our applications grow, it becomes increasingly difficult to manage state. In particular, while we are able to easily handle the transfer of information downward from a parent component to a child component with *props*, there is no easy way to pass data upward from a child component to a parent, or even to a sibling component.  Redus allows us to handle **application state**, which will be available throughout the application generally.

2. One goal of Redux is to simplify our components so that very little logic is handled by them, they are more like dummy components. This is not completely true, as the component will still report events to Redux through the action creator, but most of the logic involving state will be handled by Redux.

3. To begin, let us define some key terms used in *redux*.

    a. **Reducer**: This is merely a function that returns some data.
    
    b. **Action Creator**: This is a Javascript function that returns an *action*.
    
    b. **Action**: This is a plain javascript object that tells the reducer how to modify its data. The only requirement is that it have a **type** property,
    
    c. **State**: The application data.
    
    d. **Store**: A javascript object that holds references to the *reducer* and *state*.


### Basic Setup of Redux
1. Create our basic seed project as before.

2. With npm install, install the following: **react-redux** and **redux**.

3. In our *app.js* file, make the following additional imports:
    ```javascript
    import { Provider } from 'react-redux';
    import { createStore } from 'redux';
    ```
    The **Provider** method wraps around the **Store** (which holds all our pieces of **State** information, and makes it available to our React application. The Provider is the key connection between React and Redux.
    
4. In our *app.js* file, wrap our \<View /> tag in a \<Provider> tag as follows:
    ```javascript
    const App = () => {
        return (
            <Provider store={createStore}>
                <View />
            </Provider>
        );
    };
    ```
5. In our *src* folder, create a new folder called **reducers**, and create a file therein named **index.js** (to aggregate multiple reducers (one per file) in our reducers directory.

6. In our *reducers/index.js* file, insert the following code, which calls upon the **combineReducers** method of the *redux* library to handle the merger of multiple reducers:
    ```javascript
    import { combineReducers } from 'redux';

    export default combineReducers({
        libraries: () => []
    });
    ```
7. Go back to the *app.js* file and hook up our reducers into the *createStore()* method, by importing and then including as a parameter of the *createStore()* method:
    ```javascript
    import reducers from './reducers'
    . . .
        <Provider store={ceateStore(reducers)}>
    ```
    **Note**: The \<Provider> tag can only contain within it a single React (or React Native) child component, so be sure to wrap multiple components in a \<View> tag.
    
### Creating an Action
1. First, we will need to create a new folder in our *src* directory, named **actions**.  In that folder, create a file, *index.js*.  This is what will hold our action creators.  Set the file as in the following example:
    ```javascript
    export const selectLibrary = () => {
        return {
            type: 'select_Library'
        };
    };
    ```
    In this example *selectLibrary* is our **action creator**, and the object returned, with the type *select_Library* is our **action**.
    
    **NOTE**: In this file, we might have many different action creators.  Each one would look the same, with its own export statement. In the file where we want to call an action creator, we can import all the actions to have them available, as follows:
    ```javascrtipt
    import * as actions from '../actions';
    ``` 
    
2. Whenever we call the action creator (which, being a function, can be called), our action is sent to every reducer, one of which may recognize the action do whatever it is supposed to do on getting the action called.

3. In the above sample, what we will do in the reducer is change the id of the library chosen, when the user taps on the item in the list.  So, we need to pass in the id, and include it in our action.  This results in:
    ```javascript
    export const selectLibrary = (libraryId) => {
        return {
            type: 'select_library',
            payload: libraryId
        };
    };
    ```
    The payload gets sent with the type by the dispatcher.
    
### Calling an Action Creator
1. First, import all the action creators, as follows:
    ```javascript
    import * as actions from '../actions';
    ```
    **NOTE**: it will be more efficient to select our action creators from the total list, as follows:
    ```javascrtipt
    import { selectLibrary, selectDoofus as actions } from '../actions';
    ```
2. Next, import the **connect** method from react-redux:
    ```javascript
    import { connect } from 'react-redux';
    ```
3. The connect method takes as its first argument our **mapStateToProps** method. If we do not have that method in the module in which we are connecting our action creator, then we must pass in **null** as the first argument.  The second argument will be the entire *actions* object, as follows:
    ```javascript
    export default connect(null, actions)(ListItem);
    ```
4. By virtue of the **connect** method, we now have access to the action creator as a prop. So, if we have wired up an action creator *textChanged*, we can use it in our component as follows:
    ```javascript
    onTextInput(text) {
        this.props.textChanged(text)
    }
    ```


### The Reducer
1. The reducer is a **function** that returns some data. This function has two parameters, **state** and **action**. The *state* will be the state that was returned the last time the reducer ran, and *action* will be the action that has been dispatched.

2. The reducer function body will use a **switch** statement to provide the proper response based on the action that has been received. So, a typical reducer will look something like:
    ```javascript
    export default (state = null, action) => {
        switch (action.type) {
            case 'select_library':
                return action.payload;
            default:
                return state;
        }
    };
    ```
    Note the provision of a default value provided for 'state'.  React Native will throw an error if undefined is returned for state value, so we need to provide an initial, start-up value for state.
    
3. When the Reducer is called by the Action, it must take the old state at that time, create a **new state** (actually, only the portion of state that the particular reducer is addressing). It should **not** change the old state object. When it returns the new state object, Redux compares that with the old state object, and if there are no changes, it does not update; but if there are changes, it does update. **BUT**, if the old state is modified, then the returned object is still the same object, so Redux will not update!

4. To return a new state object, we can use the following, which is from an reducer case where the email property has been updated by the user:
    ```javascript
    return { ...state, email: action.payload };
    ```
    In the above snippet, the "..." brings in all the state object properties, and the designation of the email will either add the email property to the state, or replace the email property already in the state. The **important part** is that we are returning a new object, not a reference to the old state object.
    

    
### MapStateToProps
1. The **mapStateToProps** method does just what it says, returning an object associating a prop name with a state property, so that the component will be able to acess any designated properties. An example might be:
    ```javascript
    const mapStateToProps = state => (
        {
            libraries: state.libraries,
        }
    };
    ```

2. Note that this method is called *mapStateToProps* by convention, but it can be any name we designate. The **important thing** is that the method name is passed into the **connect** method as the first argument.

3. This method takes two arguments: **state**, being the application state, and **ownProps**, being the props that were passed to the component being wrapped by the **connect** method. So, we can perform some logic in this method, using the information. For example, if we touch on a screen section and get the identity of the section in the state, we can compare if that section matches each components id, and if it does, assign a value of true to a new prop (perhaps, "expand").

4. This method is run every time the state changes, so that props can be updated, and the page rerendered accordingly.

### Best Practice - "Types" File
1. In order to protect against hard-to-find typos in creating our action types in the action creator and referring to them in the reducer (for example, setting the action.type as "email_change" in the action creator and "email_changed" in the Reducer, a best practice is to create a **types.js** file that exports an object of type names mapped to the given name. The point is that if there is a typo, then an error will be thrown noting the unknown variable.  To set this up, take the following steps:

    a. In the *actions* folder, creeate a new file, **types.js**;
    
    b. Export from the *types.js* file a constant that equals the string name of our action, such as:
    ```javascript
    export const EMAIL_CHANGED = 'EMAIL_CHANGED';
    ```
    
    c. In the actions *index.js* file, import in the new constant, and use it as the action type:
    ```javascript
    import { EMIL_CHANGED } from './types';
    
    export const emailChanged = (text) => {
        return {
            type: EMAIL_CHANGED,
            payload: text
        };
    };
    ```
    d. In our reducer file, import the constant, and use is as the name in our switch/case statement:
    ```javascript
    switch(action.type) {
    case EMAIL_CHANGED:
        return some state;
    default:
        return state;
    ```

### Asynchronous Action Creators
1. Often, we may want to get data from another source, in an asynchronous manner, and then pass it on to the reducer.  So far, we have been writing syncronous action creators which would not wait for a return before passing on to the reducer.

2. With Thunk, action creators **return a function**, not an action object. The returned function is called automatically with 'dispatch'.

3. ReduxThunk is a middleware, and to use any middleware with Redux, we must import a module **applyMiddleware**.

4. To handle asynchronous action creators, we use a library called **redux thunk**. Start by installing with npm:
    ```javascript
    npm install --save redux-thunk
    ```
5. Next, in the *app.js* file, import redux-thunk, and the applyMiddleware:
    ```javascript
    import { createStore, applyMiddleware } from 'redux';
    import ReduxThunk from 'redux-thunk';
    ```
6. In our **store** creation, in the *render* method of the App component, place the following code:
    ```javascript
    render() {
        const = createStore(reducers, {}, applyMiddleware(ReduxThunk));
        
        return (
            <Provider store={store}>
                <LoginForm />
            </Provider>
        );
    }
    ```
    Note: the second argument takes any initial state we want to pass into Redux.
7. Next, in our action creator, we wrap our asynchronous call in a function, passing in the parameter **dispatch**. What happens is that redux, upon noting that our action creator is returning a function, allows the inner function to run, and then sends out the object to the reducers by manually calling the **dispatch** method.
    
## Routing / Navigation

1. **NOTE**: React Native does not have a universally accepted solution for navigation, in contrast to React.JS, which does have a standardized approach in the React Router. An "official" **React Navigation** module has come out but is still in beta (as of May 2017).  In this section, we will work with another solution, **react-native-router-flux** (herein, "RNRF"). 

2. RNRF approaches navigation by identifying each distinct screen as a "**scene**". A Scene is a component that is imported and placed in our code.  The scene takes a numbeer of props, including:

    a. **key**: Completely unrelated to the *key* involved in generating a list of components, This is how we identify the scene in order to navigate to it.
    
    b. **component**: This is the component that will show in the scene.
    
    c. **title**: this is the value given to RNRF's built in title bar.
    
    d. **initial**: takes no value, but indicates that the scene on which it is placed will be the one that shows on the app startup.
    
3. After installing with npm, create a file in the *src* directory named something along the lines of "Router.js". This will contain all the possible scenes that the user can go to in the app.